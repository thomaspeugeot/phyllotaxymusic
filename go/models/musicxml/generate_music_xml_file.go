package musicxml

import (
	"encoding/xml"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"time"

	musicxml "github.com/fullstack-lang/gongxsd/test/musicxml/go/models"
)

func GenerateMusicXMLFile() bool {
	log.Println("Export to Music xml requested")

	var scorePartwise musicxml.Score_partwise
	scorePartwise.XMLName.Local = "score-partwise"

	scorePartwise.A_score_partwise.Version = "4.0"

	timestamp := time.Now().Format("20060102_150405")
	scorePartwise.Work =
		&musicxml.Work{

			Name:        "genereted from phyllotaxy music",
			Work_number: "",
			Work_title:  "Generated by phyllotaxy music at" + timestamp,
			Opus: &musicxml.Opus{
				Name: "",
			},
		}
	{
		var identification musicxml.Identification
		scorePartwise.Identification = &identification

		var creator musicxml.Typed_text
		identification.Creator = append(identification.Creator, &creator)
		creator.EnclosedText = "phyllotaxy music"
		creator.Type = "composer"

		var encoding musicxml.Encoding
		identification.Encoding = &encoding

		encoding.Software = "MuseScore 4.3.2"

		{
			var supports musicxml.Supports
			encoding.Supports = append(encoding.Supports, &supports)

			supports.Type = musicxml.Enum_Yes_no_Yes
			supports.Element = "accidental"
		}
		{
			var supports musicxml.Supports
			encoding.Supports = append(encoding.Supports, &supports)

			supports.Type = musicxml.Enum_Yes_no_Yes
			supports.Element = "beam"
		}
		{
			var supports musicxml.Supports
			encoding.Supports = append(encoding.Supports, &supports)

			supports.Type = musicxml.Enum_Yes_no_Yes
			supports.Element = "print"
			supports.Attribute = "new-page"
			supports.Value = string(musicxml.Enum_Yes_no_Yes)

		}
		{
			var supports musicxml.Supports
			encoding.Supports = append(encoding.Supports, &supports)

			supports.Type = musicxml.Enum_Yes_no_Yes
			supports.Element = "print"
			supports.Attribute = "new-system"
			supports.Value = string(musicxml.Enum_Yes_no_Yes)
		}
		{
			var supports musicxml.Supports
			encoding.Supports = append(encoding.Supports, &supports)

			supports.Type = musicxml.Enum_Yes_no_Yes
			supports.Element = "stem"
		}

	}

	{

		var part musicxml.A_part
		scorePartwise.Part = append(scorePartwise.Part, &part)

		part.Id = "P1"

		var measure musicxml.A_measure
		part.Measure = append(part.Measure, &measure)

		measure.Number = "1"
		measure.Width = "269.19"

		var note musicxml.Note
		measure.Note = append(measure.Note, &note)

		note.Default_x = "82.98"
		note.Default_y = "-25"

		var pitch musicxml.Pitch
		note.Pitch = &pitch

		pitch.Step = "A"
		pitch.Octave = 4

		note.Duration = "1"
		note.Voice = "1"

		var type_ musicxml.Note_type
		note.Type = &type_

		type_.EnclosedText = "eighth"

		var stem musicxml.Stem
		note.Stem = &stem
		stem.EnclosedText = "down"

		var beam musicxml.Beam
		note.Beam = &beam

		beam.Number = 1
		beam.EnclosedText = "begin"
	}

	// Marshal the books struct back into XML
	output, err := xml.MarshalIndent(scorePartwise, "", "    ")
	if err != nil {
		fmt.Println("Error marshalling to XML:", err)
		return true
	}

	// Write the XML to a new file
	filename := generateTimestampedFilename("export", ".musicxml")
	err = os.WriteFile(
		filepath.Join("musicxml", filename),
		[]byte(xml.Header+string(output)), 0644)
	if err != nil {
		fmt.Println("Error writing to file:", err)
		return true
	}
	return false
}

// generateTimestampedFilename creates a filename using the current timestamp (YYYYMMDD_HHMMSS).
func generateTimestampedFilename(prefix, extension string) string {
	// Format current date and time up to the second
	timestamp := time.Now().Format("20060102_150405")
	// Construct the filename
	return fmt.Sprintf("%s_%s%s", prefix, timestamp, extension)
}
